# 导入函数库
from jqdata import *
import pandas as pd
import numpy as np
import datetime
from datetime import timedelta
import calendar
import cPickle as pickle
from six import StringIO
from sklearn import svm

#获取指定周期的日期列表 'W、M、Q'
def get_period_date(peroid,start_date, end_date):
    #设定转换周期period_type  转换为周是'W',月'M',季度线'Q',五分钟'5min',12天'12D'
    stock_data = get_price('000001.XSHE',start_date,end_date,'daily',fields=['close'])
    #记录每个周期中最后一个交易日
    stock_data['date']=stock_data.index
    #进行转换，周线的每个变量都等于那一周中最后一个交易日的变量值
    period_stock_data=stock_data.resample(peroid,how='last')
    date=period_stock_data.index
    pydate_array = date.to_pydatetime()
    date_only_array = np.vectorize(lambda s: s.strftime('%Y-%m-%d'))(pydate_array )
    date_only_series = pd.Series(date_only_array)
    start_date = datetime.datetime.strptime(start_date, "%Y-%m-%d")
    start_date=start_date-datetime.timedelta(days=1)
    start_date = start_date.strftime("%Y-%m-%d")
    date_list=date_only_series.values.tolist()
    date_list.insert(0,start_date)
    return date_list
    
# 初始化函数，设定基准等等
def initialize(context):
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)
    
    # 过滤掉order系列API产生的比error级别低的log
    log.set_level('order', 'error')
    
    # 数据及模型准备
    g.factor_data = get_data()
    g.model = get_model()
   # 总分层数
    g.num_total = 5
    # 层数
    g.num = 1
    
    ### 股票相关设定 ###
    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱
    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')
    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）
    run_monthly(market_open, 1,time='open', reference_security='000300.XSHG')
    
## 开盘时运行函数
def market_open(context):
    # 获取因子数据的日期
    date_previous = str(getMonthFirstDayAndLastDay(context.previous_date.year, context.previous_date.month))
    data_predict=pd.DataFrame()
    # 取股票列表
    stockList = list(g.factor_data[date_previous].index)
    # 取样本外数据特征及标签
    test_feature = g.factor_data[date_previous].copy()
    test_feature=np.array(test_feature)
    # 模型预测，输出概率
    test_predict=g.model.predict_proba(test_feature)
    # 数据统计
    data_predict['code'] = stockList
    data_predict['predict'] = test_predict[:,1]
    # 获取买入股票列表
    #buyList = list(data_predict['code'][len(stockList)/g.num_total*(g.num-1):len(stockList)/g.num_total*g.num])
    benchmark_industry_weight,industry_stocks = get_industry_weight('000300.XSHG',stockList,date_previous)
    
    data_predict.set_index('code', inplace = True)
    weight={}
    for key, value in industry_stocks.items():
        value=list(data_predict.loc[value].sort('predict',ascending = False).index)
        temp=float(len(value))/g.num_total
        for i in range(int(temp*(g.num-1)),int(ceil(temp*g.num))): 
            if i<temp*(g.num-1):
                weight[value[i]]=(int(temp*(g.num-1))+1-temp*(g.num-1))\
                                /temp*benchmark_industry_weight.loc[key]['industry_weight']
            elif i>temp*g.num-1:
                weight[value[i]]=(temp*g.num-int(temp*g.num))/temp*benchmark_industry_weight.loc[key]['industry_weight']
            else:
                weight[value[i]]=1/temp*benchmark_industry_weight.loc[key]['industry_weight']
    
    # 进行股票交易
    for stock in context.portfolio.positions.keys():
        order_target_value(stock,0)
    for stock in weight.keys(): 
        order_target_value(stock,context.portfolio.total_value*weight[stock])

# 获取当月最后一天日期
def getMonthFirstDayAndLastDay(year, month):
    year = int(year)
    month = int(month)
    # 获取当月第一天的星期和当月的总天数
    firstDayWeekDay, monthRange = calendar.monthrange(year, month)
    lastDay = datetime.date(year=year, month=month, day=monthRange)
    return lastDay
    
def get_data():
    #使用pickle模块将数据对象保存到文件
    pkl_file_read = read_file("factor_solve_data.pkl")
    factor_data = pickle.load(StringIO(pkl_file_read))
    return factor_data
    
def get_model():
    peroid='M'
    start_date='2010-01-01'
    end_date='2014-01-01'
    dateList=get_period_date(peroid,start_date, end_date)
    # 训练集数据
    train_data=pd.DataFrame()
    for date in dateList[:-1]:
        traindf=g.factor_data[date]
        stockList=list(traindf.index)
        #取收益率数据
        data_close=get_price(stockList,date,dateList[dateList.index(date)+1],'1d','close')['close']
        traindf['pchg']=data_close.iloc[-1]/data_close.iloc[0]-1
        #剔除空值
        traindf=traindf.dropna()   
        #选取前后各30%的股票，剔除中间的噪声
        traindf=traindf.sort(columns='pchg')
        traindf=traindf.iloc[:len(traindf['pchg'])/10*3,:].append(traindf.iloc[len(traindf['pchg'])/10*7:,:])
        traindf['label']=list(traindf['pchg'].apply(lambda x:1 if x>np.mean(list(traindf['pchg'])) else -1))    
        if train_data.empty:
            train_data=traindf
        else:
            train_data=train_data.append(traindf)
    # 获取特征及标签
    train_target=train_data['label']
    train_feature=train_data.copy()
    del train_feature['pchg']
    del train_feature['label']
    # 获取模型
    model = svm.SVC(C=10,gamma=0.01,kernel='rbf',probability=True)
    # 模型训练
    model.fit(np.array(train_feature),np.array(train_target))
    return model

# 取指数行业权重
def get_industry_weight(stock_index,stockList,date):
    # 获取基准成分股权重
    benchmark_weight = get_index_weights(stock_index, date)
    # 查询股票所属行业
    industry = get_industry(stockList, date)
    x = []
    y = []
    for key, content in industry.items():
        if 'sw_l1' in content.keys():
            x.append(key)
            y.append(content['sw_l1']['industry_code'])
        else:
            x.append(key)
            y.append('others')
    industry = pd.DataFrame({'code': x, 'industry_code': y})
    industry.set_index('code', inplace = True)
    # 取行业成分股
    industry_stocks={}
    for i in y:
        industry_stocks[i] = list(industry[industry['industry_code']==i].index)
    # 股票对应行业的权重
    benchmark_weight = pd.concat([benchmark_weight, industry], axis = 1)
    # 归一化后，得到沪深300成分股中，包含的行业所占权重
    benchmark_industry_weight = benchmark_weight.groupby("industry_code").sum()
    benchmark_industry_weight /= benchmark_industry_weight.sum()
    benchmark_industry_weight.columns = ['industry_weight']
    
    return benchmark_industry_weight,industry_stocks
